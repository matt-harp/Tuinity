From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: matt-harp <53673965+matt-harp@users.noreply.github.com>
Date: Thu, 2 Jul 2020 19:56:06 -0500
Subject: [PATCH] Stop sponges from getting wet and drain waterlogged blocks on
 explosion


diff --git a/src/main/java/co/chaoticpvp/ChaosConfig.java b/src/main/java/co/chaoticpvp/ChaosConfig.java
index a509f208556d9f7d67168cf055d6069bf4f20a7b..0dcb09959688e76676eef2450cd69b247233e4c2 100644
--- a/src/main/java/co/chaoticpvp/ChaosConfig.java
+++ b/src/main/java/co/chaoticpvp/ChaosConfig.java
@@ -123,13 +123,25 @@ public class ChaosConfig {
     public static boolean disableRandomTntSpread;
 
     private static void disableRandomTntSpread() {
-        disableRandomTntSpread = getBoolean("disable-random-tnt-spread", true);
+        disableRandomTntSpread = getBoolean("tnt.disable-random-spread", true);
     }
 
     public static boolean tntChainReaction;
 
     private static void tntChainReaction() {
-        tntChainReaction = getBoolean("allow-tnt-to-chain-react", false);
+        tntChainReaction = getBoolean("tnt.allow-chain-reactions", false);
+    }
+
+    public static boolean spongesGetWet;
+
+    private static void spongesGetWet() {
+        spongesGetWet = getBoolean("sponges-turn-to-wet-sponge", false);
+    }
+
+    public static boolean tntDrainsWaterloggedBlocks;
+
+    private static void tntDrainsWaterloggedBlocks() {
+        tntDrainsWaterloggedBlocks = getBoolean("tnt.explosion-drains-waterlogged-blocks", true);
     }
 
     // This is an example for adding a new Configuration Value [No section]
diff --git a/src/main/java/net/minecraft/server/BlockSponge.java b/src/main/java/net/minecraft/server/BlockSponge.java
index 362750bd85bc65c304f5fece344ecdeddebaf4ee..027948b1b3c683e941f04d2bb0acfe73c3808386 100644
--- a/src/main/java/net/minecraft/server/BlockSponge.java
+++ b/src/main/java/net/minecraft/server/BlockSponge.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import co.chaoticpvp.ChaosConfig;
 import com.google.common.collect.Lists;
 import java.util.Queue;
 // CraftBukkit start
@@ -30,7 +31,8 @@ public class BlockSponge extends Block {
 
     protected void a(World world, BlockPosition blockposition) {
         if (this.b(world, blockposition)) {
-            world.setTypeAndData(blockposition, Blocks.WET_SPONGE.getBlockData(), 2);
+            if(ChaosConfig.spongesGetWet) // Chaos sponges
+                world.setTypeAndData(blockposition, Blocks.WET_SPONGE.getBlockData(), 2);
             world.triggerEffect(2001, blockposition, Block.getCombinedId(Blocks.WATER.getBlockData()));
         }
 
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index e408ec8c645e9ceb278a13a5b0de8ecf57f3929e..6654c19c27a1597f526861b0cd38f88c82dbda8f 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import co.chaoticpvp.ChaosConfig;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -16,7 +17,9 @@ import java.util.Set;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
+import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.BlockStateListPopulator;
 import org.bukkit.event.entity.EntityExplodeEvent;
 import org.bukkit.Location;
 import org.bukkit.event.block.BlockExplodeEvent;
@@ -130,81 +133,96 @@ public class Explosion {
 
                             if (optional.isPresent()) {
                                 f -= ((Float) optional.get() + 0.3F) * 0.3F;
+                                // Chaos start
+                                if (iblockdata.hasProperty(BlockProperties.C) && ChaosConfig.tntDrainsWaterloggedBlocks) {
+                                    iblockdata = iblockdata.set(BlockProperties.C, false);
+                                    world.setTypeAndData(blockposition, iblockdata, 3);
+                                }
+                                // Chaos end
+
+                                if (!iblockdata.isAir() || !fluid.isEmpty()) {
+                                    float f2 = Math.max(iblockdata.getBlock().getDurability(), fluid.k());
+
+                                    if (this.source != null) {
+                                        f2 = this.source.a(this, this.world, blockposition, iblockdata, fluid, f2);
+                                    }
+
+                                    f -= (f2 + 0.3F) * 0.3F;
+                                }
+
+                                if (f > 0.0F && this.k.a(this, this.world, blockposition, iblockdata, f) && blockposition.getY() < 256 && blockposition.getY() >= 0) { // CraftBukkit - don't wrap explosions
+                                    set.add(blockposition);
+                                }
+
+                                d4 += d0 * 0.30000001192092896D;
+                                d5 += d1 * 0.30000001192092896D;
+                                d6 += d2 * 0.30000001192092896D;
                             }
-
-                            if (f > 0.0F && this.k.a(this, this.world, blockposition, iblockdata, f) && blockposition.getY() < 256 && blockposition.getY() >= 0) { // CraftBukkit - don't wrap explosions
-                                set.add(blockposition);
-                            }
-
-                            d4 += d0 * 0.30000001192092896D;
-                            d5 += d1 * 0.30000001192092896D;
-                            d6 += d2 * 0.30000001192092896D;
                         }
                     }
                 }
             }
-        }
 
-        this.blocks.addAll(set);
-        float f2 = this.size * 2.0F;
-
-        i = MathHelper.floor(this.posX - (double) f2 - 1.0D);
-        j = MathHelper.floor(this.posX + (double) f2 + 1.0D);
-        int l = MathHelper.floor(this.posY - (double) f2 - 1.0D);
-        int i1 = MathHelper.floor(this.posY + (double) f2 + 1.0D);
-        int j1 = MathHelper.floor(this.posZ - (double) f2 - 1.0D);
-        int k1 = MathHelper.floor(this.posZ + (double) f2 + 1.0D);
-        List<Entity> list = this.world.getEntities(this.source, new AxisAlignedBB((double) i, (double) l, (double) j1, (double) j, (double) i1, (double) k1), (com.google.common.base.Predicate<Entity>) entity -> IEntitySelector.canAITarget().test(entity) && !entity.dead); // Paper - Fix lag from explosions processing dead entities
-        Vec3D vec3d = new Vec3D(this.posX, this.posY, this.posZ);
-
-        for (int l1 = 0; l1 < list.size(); ++l1) {
-            Entity entity = (Entity) list.get(l1);
-
-            if (!entity.ch()) {
-                double d7 = (double) (MathHelper.sqrt(entity.d(vec3d)) / f2);
-
-                if (d7 <= 1.0D) {
-                    double d8 = entity.locX() - this.posX;
-                    double d9 = (entity instanceof EntityTNTPrimed ? entity.locY() : entity.getHeadY()) - this.posY;
-                    double d10 = entity.locZ() - this.posZ;
-                    double d11 = (double) MathHelper.sqrt(d8 * d8 + d9 * d9 + d10 * d10);
-
-                    if (d11 != 0.0D) {
-                        d8 /= d11;
-                        d9 /= d11;
-                        d10 /= d11;
-                        double d12 = this.getBlockDensity(vec3d, entity); // Paper - Optimize explosions
-                        double d13 = (1.0D - d7) * d12;
-
-                        // CraftBukkit start
-                        // entity.damageEntity(this.b(), (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f2 + 1.0D)));
-                        CraftEventFactory.entityDamage = source;
-                        entity.forceExplosionKnockback = false;
-                        boolean wasDamaged = entity.damageEntity(this.b(), (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f2 + 1.0D)));
-                        CraftEventFactory.entityDamage = null;
-                        if (!wasDamaged && !(entity instanceof EntityTNTPrimed || entity instanceof EntityFallingBlock) && !entity.forceExplosionKnockback) {
-                            continue;
-                        }
-                        // CraftBukkit end
-                        double d14 = d13;
+            this.blocks.addAll(set);
+            float f2 = this.size * 2.0F;
+
+            i = MathHelper.floor(this.posX - (double) f2 - 1.0D);
+            j = MathHelper.floor(this.posX + (double) f2 + 1.0D);
+            int l = MathHelper.floor(this.posY - (double) f2 - 1.0D);
+            int i1 = MathHelper.floor(this.posY + (double) f2 + 1.0D);
+            int j1 = MathHelper.floor(this.posZ - (double) f2 - 1.0D);
+            int k1 = MathHelper.floor(this.posZ + (double) f2 + 1.0D);
+            List<Entity> list = this.world.getEntities(this.source, new AxisAlignedBB((double) i, (double) l, (double) j1, (double) j, (double) i1, (double) k1), (com.google.common.base.Predicate<Entity>) entity -> IEntitySelector.canAITarget().test(entity) && !entity.dead); // Paper - Fix lag from explosions processing dead entities
+            Vec3D vec3d = new Vec3D(this.posX, this.posY, this.posZ);
+
+            for (int l1 = 0; l1 < list.size(); ++l1) {
+                Entity entity = (Entity) list.get(l1);
+
+                if (!entity.ch()) {
+                    double d7 = (double) (MathHelper.sqrt(entity.d(vec3d)) / f2);
+
+                    if (d7 <= 1.0D) {
+                        double d8 = entity.locX() - this.posX;
+                        double d9 = (entity instanceof EntityTNTPrimed ? entity.locY() : entity.getHeadY()) - this.posY;
+                        double d10 = entity.locZ() - this.posZ;
+                        double d11 = (double) MathHelper.sqrt(d8 * d8 + d9 * d9 + d10 * d10);
+
+                        if (d11 != 0.0D) {
+                            d8 /= d11;
+                            d9 /= d11;
+                            d10 /= d11;
+                            double d12 = this.getBlockDensity(vec3d, entity); // Paper - Optimize explosions
+                            double d13 = (1.0D - d7) * d12;
+
+                            // CraftBukkit start
+                            // entity.damageEntity(this.b(), (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f2 + 1.0D)));
+                            CraftEventFactory.entityDamage = source;
+                            entity.forceExplosionKnockback = false;
+                            boolean wasDamaged = entity.damageEntity(this.b(), (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f2 + 1.0D)));
+                            CraftEventFactory.entityDamage = null;
+                            if (!wasDamaged && !(entity instanceof EntityTNTPrimed || entity instanceof EntityFallingBlock) && !entity.forceExplosionKnockback) {
+                                continue;
+                            }
+                            // CraftBukkit end
+                            double d14 = d13;
 
-                        if (entity instanceof EntityLiving) {
-                            d14 = entity instanceof EntityHuman && world.paperConfig.disableExplosionKnockback ? 0 : EnchantmentProtection.a((EntityLiving) entity, d13); // Paper - Disable explosion knockback
-                        }
+                            if (entity instanceof EntityLiving) {
+                                d14 = entity instanceof EntityHuman && world.paperConfig.disableExplosionKnockback ? 0 : EnchantmentProtection.a((EntityLiving) entity, d13); // Paper - Disable explosion knockback
+                            }
 
-                        entity.setMot(entity.getMot().add(d8 * d14, d9 * d14, d10 * d14));
-                        if (entity instanceof EntityHuman) {
-                            EntityHuman entityhuman = (EntityHuman) entity;
+                            entity.setMot(entity.getMot().add(d8 * d14, d9 * d14, d10 * d14));
+                            if (entity instanceof EntityHuman) {
+                                EntityHuman entityhuman = (EntityHuman) entity;
 
-                            if (!entityhuman.isSpectator() && (!entityhuman.isCreative() || !entityhuman.abilities.isFlying) && !world.paperConfig.disableExplosionKnockback) { // Paper - Disable explosion knockback
-                                this.m.put(entityhuman, new Vec3D(d8 * d13, d9 * d13, d10 * d13));
+                                if (!entityhuman.isSpectator() && (!entityhuman.isCreative() || !entityhuman.abilities.isFlying) && !world.paperConfig.disableExplosionKnockback) { // Paper - Disable explosion knockback
+                                    this.m.put(entityhuman, new Vec3D(d8 * d13, d9 * d13, d10 * d13));
+                                }
                             }
                         }
                     }
                 }
             }
         }
-
     }
 
     public void a(boolean flag) {
